version: '3.8'
services:
  app:
    build:
      context: . # Assumes Dockerfile is in the same directory
      dockerfile: Dockerfile # Explicitly state Dockerfile name
    ports:
      - "4000:4000" # Changed to 4000 based on your index.js
    environment:
      # Example environment variables (adjust as per your index.js)
      NODE_ENV: production
      PORT: 4000
      # DB_PATH: /app/serviceB.sqlite # This path will be inside the container
      # SERVICE_A_URL: http://service-a:3000 # If Service A is another Docker service
    volumes:
      # Mount a volume for persistent SQLite data
      - app_data:/app/serviceB.sqlite # Or to a specific 'db' directory inside the container if your code expects it
      # If your index.js has DB_PATH as `./serviceB.sqlite`, then mounting to /app/serviceB.sqlite is good.
      # If your index.js has DB_PATH as `./db/serviceB.sqlite`, then mount - app_data:/app/db/serviceB.sqlite
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4000/health"] # Updated port
      interval: 10s # Check every 10 seconds
      timeout: 5s   # Fail if it doesn't respond in 5 seconds
      retries: 5    # Try 5 times before marking as unhealthy
      start_period: 30s # Give the app 30 seconds to start before first check
    restart: unless-stopped # Automatically restart unless manually stopped

  prometheus:
    image: prom/prometheus:latest # It's good to specify a tag
    container_name: prometheus
    volumes:
      - ./infra/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus # Optional: persistent storage for Prometheus data
    ports:
      - "9090:9090"
    command: --config.file=/etc/prometheus/prometheus.yml --web.enable-lifecycle # Enable reload from config file
    restart: unless-stopped

# Define named volumes for persistence
volumes:
  app_data:
  prometheus_data:

  